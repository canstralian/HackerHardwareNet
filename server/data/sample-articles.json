[
  {
    "id": 1,
    "title": "Running a 0.96\" OLED Display on Your Orange Pi Zero 2W and Raspberry Pi Zero 2W",
    "content": "# Running a 0.96\" OLED Display on Your Orange Pi Zero 2W and Raspberry Pi Zero 2W\n\nIn this tutorial, we'll show you how to connect and run a 4-pin 0.96\" OLED (typically an SSD1306/SH1106 module) on two popular single-board computers: the Orange Pi Zero 2W and the Raspberry Pi Zero 2W. Whether you're hacking together a custom IoT display or integrating status information into your security projects, this guide provides step-by-step instructions for wiring, configuring the software, and writing your first \"Hello World\" display program.\n\n## Overview\n\n### What You'll Learn:\n- How to wire the 4-pin OLED display to the SBC (Single Board Computer)\n- How to enable and test I²C communication on both boards\n- Installing Python libraries and running sample code that displays text and graphics\n- Tips for troubleshooting common issues\n\n### Who This is For:\nHackers, makers, and tinkerers working with low-cost SBCs who want to add a compact OLED interface to monitor system status or display messages.\n\n## Required Components & Tools\n\n### Hardware:\n- 0.96\" OLED display (4-pin; VCC, GND, SDA, SCL) based on the SSD1306 (or compatible SH1106) driver\n- Orange Pi Zero 2W board\n- Raspberry Pi Zero 2W board\n- Female-to-male jumper wires or DuPont cables (four per board)\n- Breadboard (optional)\n- Micro USB power supply\n- (Optional) Case\n\n### Software:\n- Linux-based development system\n- Terminal access via SSH or serial\n- Python 3\n- Required Python libraries:\n  - luma.oled or Adafruit CircuitPython SSD1306\n\n### Tools:\n- Computer\n- Terminal/SSH client\n\n## Step 1: Wiring the OLED Display\n\nBoth boards use the I²C interface. The 4-pin OLED connector maps as follows:\n- VCC: 3.3V\n- GND: Ground\n- SDA: I²C data\n- SCL: I²C clock\n\n### Wiring Diagram\n- OLED VCC → 3.3V pin on the board\n- OLED GND → Ground (GND)\n- OLED SDA → I²C SDA pin\n- OLED SCL → I²C SCL pin\n\nCheck your board's pinout diagram for exact pin numbers.\n\n## Step 2: Enabling I²C on Your Board\n\n### Raspberry Pi Zero 2W:\n\n```bash\nsudo raspi-config\n```\n\nEnable I²C under Interfacing Options. Reboot:\n\n```bash\nsudo reboot\n```\n\nInstall tools:\n\n```bash\nsudo apt-get install i2c-tools\nsudo i2cdetect -y 1\n```\n\nLook for address (commonly 0x3C).\n\n### Orange Pi Zero 2W:\n\nInstall tools:\n\n```bash\nsudo apt-get update\nsudo apt-get install i2c-tools python3-smbus\n```\n\nCheck devices:\n\n```bash\nsudo i2cdetect -y 0\n```\n\nAdjust bus number if needed.\n\n## Step 3: Installing and Testing the Software\n\n### Option A: luma.oled Library\n\nInstall:\n\n```bash\nsudo apt-get install python3-pip python3-dev python3-pil\nsudo pip3 install luma.oled\n```\n\nCreate oled_test.py:\n\n```python\nfrom luma.core.interface.serial import i2c\nfrom luma.oled.device import ssd1306\nfrom luma.core.render import canvas\nfrom PIL import ImageFont\nimport time\n\nWIDTH = 128\nHEIGHT = 64\n\nserial = i2c(port=1, address=0x3C)\ndevice = ssd1306(serial)\n\nwhile True:\n    with canvas(device) as draw:\n        font = ImageFont.load_default()\n        text = \"Hello World!\"\n        text_width, text_height = font.getsize(text)\n        draw.text(((WIDTH - text_width) // 2, (HEIGHT - text_height) // 2), text, font=font, fill=255)\n    time.sleep(1)\n```\n\nRun:\n\n```bash\npython3 oled_test.py\n```\n\n### Option B: Adafruit CircuitPython SSD1306\n\nInstall:\n\n```bash\nsudo pip3 install adafruit-blinka adafruit-circuitpython-ssd1306\n```\n\nCreate oled_circuitpython.py:\n\n```python\nimport board\nimport time\nfrom PIL import Image, ImageDraw, ImageFont\nimport adafruit_ssd1306\n\nWIDTH = 128\nHEIGHT = 64\n\ni2c = board.I2C()\noled = adafruit_ssd1306.SSD1306_I2C(WIDTH, HEIGHT, i2c, addr=0x3C)\n\noled.fill(0)\noled.show()\n\nimage = Image.new(\"1\", (WIDTH, HEIGHT))\ndraw = ImageDraw.Draw(image)\n\ndraw.rectangle((0, 0, WIDTH, HEIGHT), outline=255, fill=255)\nBORDER = 5\ndraw.rectangle((BORDER, BORDER, WIDTH - BORDER - 1, HEIGHT - BORDER - 1), outline=0, fill=0)\n\nfont = ImageFont.load_default()\ntext = \"Hello World!\"\ntext_width, text_height = draw.textsize(text, font=font)\ndraw.text(((WIDTH - text_width) // 2, (HEIGHT - text_height) // 2), text, font=font, fill=255)\n\noled.image(image)\noled.show()\n\nwhile True:\n    time.sleep(1)\n```\n\nRun:\n\n```bash\npython3 oled_circuitpython.py\n```\n\n## Step 4: Testing and Troubleshooting\n\n### Check I²C Communication:\n\n```bash\ni2cdetect -y 1\n```\n\nor\n\n```bash\ni2cdetect -y 0\n```\n\n### Issues:\n- Blank screen: verify wiring\n- No I²C address: confirm bus number\n- Import errors: check Python version and libraries\n- Display timeout: keep a loop or delay active\n\n## Final Thoughts\n\nYou now have your OLED showing \"Hello World!\" on both boards. Possible next steps:\n- Displaying graphics and sensor data\n- Status monitoring applications\n- Custom IoT dashboard displays",
    "preview": "Learn how to connect and configure a 0.96\" OLED display with an Orange Pi Zero 2W or Raspberry Pi Zero 2W. This step-by-step guide covers wiring, software setup, and programming examples to get your display up and running.",
    "category": "hardware",
    "imageUrl": "/assets/oled_display.svg",
    "publishedAt": "2025-04-14T12:21:00.000Z",
    "readTime": "10 min read",
    "tags": ["OLED", "Raspberry Pi", "Orange Pi", "I2C", "IoT", "Cybersecurity", "Hardware Tutorial"],
    "authorId": 1,
    "views": 124,
    "relatedCourseIds": [3, 5],
    "relatedProductIds": [7, 12]
  },
  {
    "id": 2,
    "title": "Building a Rogue Access Point with Raspberry Pi",
    "content": "# Building a Rogue Access Point with Raspberry Pi\n\nLearn how to set up a WiFi honeypot for network security testing and demonstration of man-in-the-middle attacks using a Raspberry Pi.\n\nThis tutorial will guide you through the process of creating a rogue access point (AP) using a Raspberry Pi. This setup can be used in a controlled environment to understand network vulnerabilities and demonstrate man-in-the-middle (MITM) attacks. Please remember that using this for unauthorized access or malicious activities is illegal and unethical. This tutorial is for educational purposes only.\n\n## What you'll learn:\n* Configure wireless interfaces in monitor mode\n* Set up DHCP and DNS spoofing\n* Implement transparent SSL proxying\n* Analyze captured network traffic\n\n## Prerequisites:\n* Raspberry Pi (Model 3 B+ or later recommended for better WiFi performance)\n* Raspberry Pi OS (Lite version is sufficient)\n* MicroSD card (at least 16GB)\n* USB WiFi adapter (recommended for better control and performance, especially one that supports monitor mode and packet injection)\n* Ethernet cable (for initial setup and internet access for the Pi)\n* A computer to SSH into the Raspberry Pi\n\n## Estimated Time: 2.5 hours\n## Difficulty: Advanced\n\n## Step 1: Setting up the Raspberry Pi\n* Install Raspberry Pi OS: Download and install Raspberry Pi OS (Lite or with Desktop) onto your microSD card using the Raspberry Pi Imager or a similar tool.\n* Enable SSH: For a headless setup (without a monitor), enable SSH by creating an empty file named ssh in the root of the boot partition of the SD card.\n* Boot the Raspberry Pi: Insert the microSD card into your Raspberry Pi and power it on.\n* Connect via SSH: Connect your computer to the same network as the Raspberry Pi (initially via Ethernet). Use the default username (pi) and password (raspberry) to SSH into the Pi. You might need to find the Pi's IP address using your router's administration interface or a network scanning tool.\n\n```bash\nssh pi@<your_pi_ip_address>\n```\n\n* Update and Upgrade: Once logged in, update and upgrade the system packages:\n\n```bash\nsudo apt update\nsudo apt full-upgrade -y\n```\n\n* Install Necessary Tools: Install the required software packages:\n\n```bash\nsudo apt install -y hostapd dnsmasq iptables libnetfilter-queue-dev python3 python3-pip\nsudo pip3 install scapy\n```\n\n## Step 2: Configuring the Wireless Interface for Monitor Mode\n* Identify Wireless Interface(s): List the available network interfaces to identify your WiFi adapter(s).\n\n```bash\niwconfig\n```\n\nYou'll likely see wlan0 (the Raspberry Pi's built-in WiFi) and possibly wlan1 (your USB WiFi adapter). Note the name of the interface you intend to use for the rogue AP. It's generally recommended to use a separate USB adapter for this purpose. Let's assume your USB adapter is wlan1.\n\n* Stop Network Services: Stop the wpa_supplicant service, which manages WiFi connections, as it can interfere with monitor mode.\n\n```bash\nsudo systemctl stop wpa_supplicant\nsudo systemctl disable wpa_supplicant\n```\n\n* Bring Down the Interface: Take down the wireless interface.\n\n```bash\nsudo ip link set wlan1 down\n```\n\n* Set to Monitor Mode: Put the wireless interface into monitor mode.\n\n```bash\nsudo iwconfig wlan1 mode monitor\n```\n\n* Bring Up the Interface: Bring the wireless interface back up.\n\n```bash\nsudo ip link set wlan1 up\n```\n\n* Verify Monitor Mode: Check if the interface is in monitor mode.\n\n```bash\niwconfig wlan1\n```\n\nYou should see Mode:Monitor in the output.\n\n## Step 3: Setting up the Rogue Access Point (hostapd)\n* Create hostapd Configuration File: Create a configuration file for hostapd.\n\n```bash\nsudo nano /etc/hostapd/hostapd.conf\n```\n\n* Edit the Configuration File: Add the following configuration, adjusting the parameters as needed:\n\n```\ninterface=wlan1\nssid=FreePlus # Your desired network name (SSID)\nchannel=1 # Choose a channel (1, 6, or 11 are common)\nhw_mode=g # Or a for 5GHz if your adapter supports it\nwpa=2\nwpa_passphrase=password123 # Your desired password\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP CCMP\nrsn_pairwise=CCMP\n```\n\n  * interface: The name of your wireless interface in monitor mode.\n  * ssid: The name of your rogue access point.\n  * channel: The WiFi channel to operate on.\n  * hw_mode: The wireless mode (g for 2.4GHz, a for 5GHz).\n  * wpa, wpa_passphrase, etc.: Security settings for your AP. You can also create an open network by removing these lines.\n\n* Save and Close: Save the file (Ctrl+X, then Y, then Enter).\n\n* Configure hostapd to Use the Configuration File: Edit the default hostapd configuration file to point to your custom file.\n\n```bash\nsudo nano /etc/default/hostapd\n```\n\nUncomment the line #DAEMON_CONF=\"\" and change it to:\n\n```\nDAEMON_CONF=\"/etc/hostapd/hostapd.conf\"\n```\n\n* Start hostapd: Try starting the hostapd service.\n\n```bash\nsudo systemctl start hostapd\n```\n\nIf you encounter errors, check the logs using sudo journalctl -u hostapd.service and ensure your wireless adapter is compatible and properly configured. You might need to kill any conflicting processes using sudo killall wpa_supplicant or sudo killall dhcpcd.\n\n## Step 4: Setting up DHCP and DNS Spoofing (dnsmasq)\n* Configure dnsmasq: Create or edit the dnsmasq configuration file.\n\n```bash\nsudo nano /etc/dnsmasq.conf\n```\n\nComment out or remove any existing lines and add the following:\n\n```\ninterface=wlan1\ndhcp-range=192.168.4.2,192.168.4.20,24h\ndhcp-option=3,192.168.4.1 # Gateway (our Pi's IP)\ndhcp-option=6,192.168.4.1 # DNS server (our Pi's IP)\nserver=8.8.8.8 # Forward DNS queries to Google's DNS (optional, for internet access)\nserver=/example.com/192.168.4.1 # Example DNS spoofing\n```\n\n  * interface: The wireless interface.\n  * dhcp-range: The range of IP addresses to assign to clients.\n  * dhcp-option=3: Sets the default gateway for clients.\n  * dhcp-option=6: Sets the DNS server for clients.\n  * server: Specifies upstream DNS servers.\n  * server=/example.com/192.168.4.1: This line demonstrates DNS spoofing. Any request for example.com will be directed to the Pi's IP address.\n\n* Set a Static IP Address for the Wireless Interface: Assign a static IP address to your wireless interface.\n\n```bash\nsudo nano /etc/dhcpcd.conf\n```\n\nAdd the following lines at the end of the file (replace wlan1 with your interface if needed):\n\n```\ninterface wlan1\nstatic ip_address=192.168.4.1/24\n```\n\n* Restart Services: Restart the dhcpcd, hostapd, and dnsmasq services.\n\n```bash\nsudo systemctl daemon-reload\nsudo systemctl restart dhcpcd\nsudo systemctl restart hostapd\nsudo systemctl restart dnsmasq\n```\n\n## Step 5: Enabling IP Forwarding and Setting up NAT\nTo allow clients connected to your rogue AP to access the internet (if desired), you need to enable IP forwarding and set up Network Address Translation (NAT).\n\n* Enable IP Forwarding:\n\n```bash\nsudo sysctl net.ipv4.ip_forward=1\n```\n\nTo make this permanent across reboots, edit the sysctl.conf file:\n\n```bash\nsudo nano /etc/sysctl.conf\n```\n\nUncomment the line #net.ipv4.ip_forward=1. Save and close the file.\n\n* Set up NAT with iptables: Assuming your Raspberry Pi is connected to the internet via eth0, use the following iptables rules:\n\n```bash\nsudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nsudo iptables -A FORWARD -i wlan1 -o eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT\nsudo iptables -A FORWARD -i eth0 -o wlan1 -j ACCEPT\n```\n\nIf you are using wlan0 for internet connectivity, replace eth0 with wlan0 in the commands above.\n\n* Save iptables Rules: To make these rules persistent across reboots, you can install the iptables-persistent package:\n\n```bash\nsudo apt install -y iptables-persistent\n```\n\nWhen prompted, choose to save the current IPv4 and IPv6 rules.\n\n## Step 6: Implementing Transparent SSL Proxying (mitmproxy)\nmitmproxy is a powerful tool for intercepting, inspecting, modifying, and replaying web traffic.\n\n* Install mitmproxy: If you haven't already, install mitmproxy.\n\n```bash\nsudo pip3 install mitmproxy\n```\n\n* Redirect HTTP and HTTPS Traffic: Use iptables to redirect HTTP (port 80) and HTTPS (port 443) traffic to mitmproxy's default ports (8080 and 8081 respectively).\n\n```bash\nsudo iptables -t nat -A PREROUTING -i wlan1 -p tcp --dport 80 -j REDIRECT --to-ports 8080\nsudo iptables -t nat -A PREROUTING -i wlan1 -p tcp --dport 443 -j REDIRECT --to-ports 8081\n```\n\n* Run mitmproxy: Start mitmproxy in transparent mode.\n\n```bash\nsudo mitmproxy --mode transparent --ssl-insecure\n```\n\n  * --mode transparent: Enables transparent proxying.\n  * --ssl-insecure: Disables SSL certificate verification (for demonstration purposes only, be cautious in real-world scenarios).\n\nNow, any HTTP or HTTPS traffic from a client connected to your rogue AP will be intercepted by mitmproxy, allowing you to inspect the requests and responses. You can view the intercepted traffic in the mitmproxy interface. Press q to quit.\n\n## Step 7: Analyzing Captured Network Traffic (tcpdump/tshark)\nYou can use tools like tcpdump or tshark (the command-line version of Wireshark) to capture and analyze network traffic.\n\n* Capture Traffic with tcpdump:\n\n```bash\nsudo tcpdump -i wlan1 -w capture.pcap\n```\n\nThis command will capture all traffic on the wlan1 interface and save it to a file named capture.pcap. You can later analyze this file with Wireshark. To filter traffic, you can add expressions like tcp port 80 for HTTP traffic or host <target_ip>.\n\n* Capture Traffic with tshark:\n\n```bash\nsudo tshark -i wlan1 -w capture.pcap\n```\n\ntshark offers more advanced filtering options. Refer to the tshark documentation for details.\n\n## Demonstration and Testing:\n* Connect a Client Device: Connect a laptop or smartphone to the WiFi network you created (e.g., \"FreePlus\").\n* Browse the Internet: Try Browse some websites on the client device.\n* Observe Traffic:\n  * mitmproxy: You should see the HTTP and HTTPS requests and responses in the mitmproxy interface on your Raspberry Pi.\n  * tcpdump/tshark: Stop the capture after some Browse and then analyze the capture.pcap file using Wireshark on your computer. You should see the network packets exchanged.\n* Test DNS Spoofing: Try accessing the domain you configured for spoofing (e.g., example.com). You should be redirected to the IP address of your Raspberry Pi (192.168.4.1).\n\n## Important Considerations and Security Best Practices:\n* Ethical Use: This setup should only be used in controlled environments for educational and testing purposes with explicit permission.\n* Security Risks: Running a rogue AP can expose your Raspberry Pi and the connected network to security risks. Ensure your Pi is not directly connected to your primary network during testing.\n* Legal Implications: Creating and using rogue access points without authorization is illegal in most jurisdictions.\n* Cleanup: After testing, remember to disable the rogue AP services and revert any configuration changes. You can re-enable your original WiFi by starting wpa_supplicant and configuring your WiFi settings.\n* Advanced Techniques: This tutorial covers the basics. You can further enhance your rogue AP with tools for packet injection, more sophisticated MITM attacks (like ARP spoofing), and captive portals.\n\nThis tutorial provides a foundation for understanding how rogue access points work and the potential security implications. Remember to use this knowledge responsibly and ethically.",
    "preview": "Learn how to set up a WiFi honeypot for network security testing and demonstration of man-in-the-middle attacks using a Raspberry Pi. This advanced tutorial provides step-by-step instructions for creating a controlled environment to understand MITM vulnerabilities.",
    "category": "network-security",
    "imageUrl": "/assets/rogue_access_point.svg",
    "publishedAt": "2025-04-10T21:14:00.000Z",
    "readTime": "15 min read",
    "tags": ["Raspberry Pi", "Network Security", "WiFi", "MITM", "Honeypot", "Cybersecurity", "Ethical Hacking"],
    "authorId": 1,
    "views": 89,
    "relatedCourseIds": [2, 8],
    "relatedProductIds": [4, 9]
  },
  {
    "id": 3,
    "title": "Improving UX for Cybersecurity Technical Portals",
    "content": "# Improving UX for Cybersecurity Technical Portals\n\nImproving UX for technical portals—especially those focused on learning, tools, and hardware documentation—requires a mix of clarity, accessibility, and efficient navigation. Based on the structure and content of the provided portal, the following UX improvements significantly enhance readability:\n\n## Key UX Improvements for Technical Learning Platforms\n\n### 1. Hierarchical Navigation and Categorization\nGrouping content under clearly labeled sections (e.g., \"HARDWARE PLATFORMS\", \"SECURITY TOOLS\", \"RESOURCES\") provides intuitive wayfinding, minimizing cognitive load.\n\n### 2. Consistent and Legible Typography\nThe use of system-ui and monospace fonts for general and code-related content respectively ensures legibility across platforms and contexts, supporting both textual and technical comprehension.\n\n### 3. Whitespace and Padding\nAdequate spacing between elements (such as in `.5rem .75rem` padding for inputs) reduces clutter, helping users process information more easily.\n\n### 4. Semantic HTML Elements\nUse of `<h1>` to `<h6>` for headings, `<nav>` for navigation, and descriptive `<a>` tags improves structure, accessibility, and screen reader compatibility.\n\n### 5. Minimalist Visual Design\nA clean, borderless design with clear hover/click states and reduced visual noise allows users to focus on core content, which is especially important in technical domains where clarity matters.\n\n### 6. Contextual Search Bar\nA prominently placed \"Search knowledge base...\" field facilitates quick access to precise information, a must-have for documentation-heavy portals.\n\n### 7. Persistent Navigation\nFixed or consistently accessible menus (e.g., [Home], [Learning Paths], [Articles]) promote user orientation and allow users to return to known locations easily.\n\n### 8. Highlighting Functional Elements\nTool categories like [Compatibility Checker] and platform-specific links offer actionable paths, enhancing user engagement with targeted utility.\n\n## Implementation Strategies\n\n### Color Contrast and Accessibility\nEnsure all text has sufficient contrast against its background, with a minimum ratio of 4.5:1 for normal text and 3:1 for large text. This is particularly important in cybersecurity portals where users may need to carefully distinguish between similar looking commands or code blocks.\n\n### Interactive Elements\nMake interactive elements (buttons, links, tabs) clearly distinguishable from static content. Use consistent hover and focus states to indicate interactivity. This helps users navigate more efficiently through complex technical documentation.\n\n### Code Block Presentation\nIn tutorials and guides that include code snippets, use syntax highlighting, line numbers, and copy buttons to improve readability and usability. This is essential for learning materials in cybersecurity education.\n\n### Mobile-Responsive Design\nEnsure the portal is fully responsive across different screen sizes and devices. Technical learners often switch between desktop for in-depth learning and mobile for quick reference.\n\n### Progress Tracking\nImplement visual indicators for course or tutorial progress to help users track their learning journey. This feature is particularly valuable in comprehensive cybersecurity educational platforms.\n\n## Cybersecurity-Specific Considerations\n\n### Security Level Indicators\nUse visual cues to indicate the complexity or security requirements of different tutorials or tools. This helps users select content appropriate to their skill level.\n\n### Tool Integration Guidance\nProvide clear instructions for integrating various security tools, with compatibility information prominently displayed to prevent frustration during setup.\n\n### Command Syntax Highlighting\nImplement specialized syntax highlighting for command-line instructions, distinguishing between commands, parameters, and expected outputs. This reduces errors during complex cybersecurity operations.\n\n### Visual Data Representation\nUse diagrams, flowcharts, and other visual aids to explain complex security concepts, network topologies, or attack vectors. This helps users grasp abstract security principles more easily.\n\n## Conclusion\n\nBy implementing these UX improvements, cybersecurity education platforms can significantly enhance user engagement, learning outcomes, and overall satisfaction. The key is balancing technical accuracy with accessibility, ensuring that complex security concepts are presented in a way that's approachable but not oversimplified.",
    "preview": "Learn essential UX design principles for technical learning platforms with a focus on cybersecurity education portals. This article covers navigation patterns, typography, accessibility, and specialized considerations for security-focused content.",
    "category": "design",
    "imageUrl": "/assets/ux_design.svg",
    "publishedAt": "2025-04-22T23:40:00.000Z",
    "readTime": "8 min read",
    "tags": ["UX Design", "Cybersecurity", "Technical Documentation", "Accessibility", "Information Architecture"],
    "authorId": 1,
    "views": 34,
    "relatedCourseIds": [10, 12],
    "relatedProductIds": [3, 15]
  }
]
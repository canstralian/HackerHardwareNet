[
  {
    "id": 1,
    "title": "Running a 0.96″ OLED Display on Your Orange Pi Zero 2W and Raspberry Pi Zero 2W",
    "preview": "Learn how to connect and run a 4-pin 0.96″ OLED display on two popular single-board computers for IoT projects and security monitoring applications.",
    "content": "# Running a 0.96″ OLED Display on Your Orange Pi Zero 2W and Raspberry Pi Zero 2W\n\nIn this tutorial, we'll show you how to connect and run a 4‑pin 0.96″ OLED (typically an SSD1306/SH1106 module) on two popular single‑board computers: the Orange Pi Zero 2W and the Raspberry Pi Zero 2W. Whether you're hacking together a custom IoT display or integrating status information into your security projects, this guide provides step‑by‑step instructions for wiring, configuring the software, and writing your first \"Hello World\" display program.\n\n## Overview\n\n### What You'll Learn:\n- How to wire the 4‑pin OLED display to the SBC (Single Board Computer)\n- How to enable and test I²C communication on both boards\n- Installing Python libraries and running sample code that displays text and graphics\n- Tips for troubleshooting common issues\n\n### Who This is For:\nHackers, makers, and tinkerers working with low‑cost SBCs who want to add a compact OLED interface to monitor system status or display messages.\n\n## Required Components & Tools\n\n### Hardware:\n- 0.96″ OLED display (4‑pin; VCC, GND, SDA, SCL) based on the SSD1306 (or compatible SH1106) driver\n- Orange Pi Zero 2W board\n- Raspberry Pi Zero 2W board\n- Female-to‑male jumper wires or DuPont cables (four per board)\n- Breadboard (optional)\n- Micro USB power supply\n\n### Software:\n- Linux‑based development system\n- Terminal access via SSH or serial\n- Python 3\n- Required Python libraries:\n  - luma.oled or Adafruit CircuitPython SSD1306\n\n## Step 1: Wiring the OLED Display\n\nBoth boards use the I²C interface. The 4-pin OLED connector maps as follows:\n- VCC: 3.3V\n- GND: Ground\n- SDA: I²C data\n- SCL: I²C clock\n\n### Wiring Diagram\n- OLED VCC → 3.3V pin on the board\n- OLED GND → Ground (GND)\n- OLED SDA → I²C SDA pin\n- OLED SCL → I²C SCL pin\n\nCheck your board's pinout diagram for exact pin numbers.\n\n## Step 2: Enabling I²C on Your Board\n\n### Raspberry Pi Zero 2W:\n\n```bash\nsudo raspi-config\n```\n\nEnable I²C under Interfacing Options. Reboot:\n\n```bash\nsudo reboot\n```\n\nInstall tools:\n\n```bash\nsudo apt-get install i2c-tools\nsudo i2cdetect -y 1\n```\n\nLook for address (commonly 0x3C).\n\n### Orange Pi Zero 2W:\n\nInstall tools:\n\n```bash\nsudo apt-get update\nsudo apt-get install i2c-tools python3-smbus\n```\n\nCheck devices:\n\n```bash\nsudo i2cdetect -y 0\n```\n\nAdjust bus number if needed.\n\n## Step 3: Installing and Testing the Software\n\n### Option A: luma.oled Library\n\nInstall:\n\n```bash\nsudo apt-get install python3-pip python3-dev python3-pil\nsudo pip3 install luma.oled\n```\n\nCreate oled_test.py:\n\n```python\nfrom luma.core.interface.serial import i2c\nfrom luma.oled.device import ssd1306\nfrom luma.core.render import canvas\nfrom PIL import ImageFont\nimport time\n\nWIDTH = 128\nHEIGHT = 64\n\nserial = i2c(port=1, address=0x3C)\ndevice = ssd1306(serial)\n\nwhile True:\n    with canvas(device) as draw:\n        font = ImageFont.load_default()\n        text = \"Hello World!\"\n        text_width, text_height = font.getsize(text)\n        draw.text(((WIDTH - text_width) // 2, (HEIGHT - text_height) // 2), text, font=font, fill=255)\n    time.sleep(1)\n```\n\nRun:\n\n```bash\npython3 oled_test.py\n```\n\n## Final Thoughts\n\nYou now have your OLED showing \"Hello World!\" on both boards. Possible next steps:\n- Displaying graphics and sensor data\n- Status monitoring applications\n- Custom IoT dashboard displays\n\n*Want to learn more? Check out our [Hardware Starter Kit](/hardware-library) which includes the Orange Pi Zero 2W and an OLED display, or enroll in our [IoT Security Learning Path](/learning-paths) for more advanced projects.*",
    "category": "hardware",
    "imageUrl": "https://i.imgur.com/XfQVdA8.jpg",
    "authorId": 1,
    "publishedAt": "2025-04-10T14:30:00Z",
    "readTime": "12 min read",
    "tags": ["orange pi", "raspberry pi", "oled", "i2c", "python", "iot"],
    "relatedArticleIds": [2, 3],
    "views": 253
  },
  {
    "id": 2,
    "title": "Building a Rogue Access Point with Raspberry Pi",
    "preview": "Learn how to set up a WiFi honeypot for network security testing and demonstration of man-in-the-middle attacks using a Raspberry Pi.",
    "content": "# Building a Rogue Access Point with Raspberry Pi\n\nThis tutorial will guide you through the process of creating a rogue access point (AP) using a Raspberry Pi. This setup can be used in a controlled environment to understand network vulnerabilities and demonstrate man-in-the-middle (MITM) attacks. Please remember that using this for unauthorized access or malicious activities is illegal and unethical. This tutorial is for educational purposes only.\n\n## What you'll learn:\n- Configure wireless interfaces in monitor mode\n- Set up DHCP and DNS spoofing\n- Implement transparent SSL proxying\n- Analyze captured network traffic\n\n## Prerequisites:\n- Raspberry Pi (Model 3 B+ or later recommended for better WiFi performance)\n- Raspberry Pi OS (Lite version is sufficient)\n- MicroSD card (at least 16GB)\n- USB WiFi adapter (recommended for better control and performance, especially one that supports monitor mode and packet injection)\n- Ethernet cable (for initial setup and internet access for the Pi)\n- A computer to SSH into the Raspberry Pi\n\n**Estimated Time:** 2.5 hours\n**Difficulty:** Advanced\n\n## Step 1: Setting up the Raspberry Pi\n\n- Install Raspberry Pi OS: Download and install Raspberry Pi OS (Lite or with Desktop) onto your microSD card using the Raspberry Pi Imager or a similar tool.\n- Enable SSH: For a headless setup (without a monitor), enable SSH by creating an empty file named ssh in the root of the boot partition of the SD card.\n- Boot the Raspberry Pi: Insert the microSD card into your Raspberry Pi and power it on.\n- Connect via SSH: Connect your computer to the same network as the Raspberry Pi (initially via Ethernet). Use the default username (pi) and password (raspberry) to SSH into the Pi.\n\n```bash\nssh pi@<your_pi_ip_address>\n```\n\n- Update and Upgrade: Once logged in, update and upgrade the system packages:\n\n```bash\nsudo apt update\nsudo apt full-upgrade -y\n```\n\n- Install Necessary Tools: Install the required software packages:\n\n```bash\nsudo apt install -y hostapd dnsmasq iptables libnetfilter-queue-dev python3 python3-pip\nsudo pip3 install scapy\n```\n\n## Step 2: Configuring the Wireless Interface for Monitor Mode\n\n- Identify Wireless Interface(s): List the available network interfaces to identify your WiFi adapter(s).\n\n```bash\niwconfig\n```\n\nYou'll likely see wlan0 (the Raspberry Pi's built-in WiFi) and possibly wlan1 (your USB WiFi adapter). Note the name of the interface you intend to use for the rogue AP.\n\n- Stop Network Services: Stop the wpa_supplicant service, which manages WiFi connections, as it can interfere with monitor mode.\n\n```bash\nsudo systemctl stop wpa_supplicant\nsudo systemctl disable wpa_supplicant\n```\n\n- Bring Down the Interface: Take down the wireless interface.\n\n```bash\nsudo ip link set wlan1 down\n```\n\n- Set to Monitor Mode: Put the wireless interface into monitor mode.\n\n```bash\nsudo iwconfig wlan1 mode monitor\n```\n\n## Step 3: Setting up the Rogue Access Point (hostapd)\n\n- Create hostapd Configuration File: Create a configuration file for hostapd.\n\n```bash\nsudo nano /etc/hostapd/hostapd.conf\n```\n\n- Edit the Configuration File: Add the following configuration, adjusting the parameters as needed:\n\n```\ninterface=wlan1\nssid=EvilAP # Your desired network name (SSID)\nchannel=1 # Choose a channel (1, 6, or 11 are common)\nhw_mode=g # Or a for 5GHz if your adapter supports it\nwpa=2\nwpa_passphrase=password123 # Your desired password\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP CCMP\nrsn_pairwise=CCMP\n```\n\n## Important Considerations and Security Best Practices:\n\n- Ethical Use: This setup should only be used in controlled environments for educational and testing purposes with explicit permission.\n- Security Risks: Running a rogue AP can expose your Raspberry Pi and the connected network to security risks. Ensure your Pi is not directly connected to your primary network during testing.\n- Legal Implications: Creating and using rogue access points without authorization is illegal in most jurisdictions.\n\n*To learn more about ethical hacking and network security, consider enrolling in our [Network Security Fundamentals Course](/learning-paths) or purchasing our [Advanced Wireless Hacking Kit](/hardware-library) which includes a pre-configured Raspberry Pi and compatible WiFi adapters.*",
    "category": "security",
    "imageUrl": "https://i.imgur.com/Qc7Ntkq.jpg",
    "authorId": 2,
    "publishedAt": "2025-04-08T09:15:00Z",
    "readTime": "15 min read",
    "tags": ["raspberry pi", "ethical hacking", "wifi security", "network security", "mitm"],
    "relatedArticleIds": [1, 3],
    "views": 489
  },
  {
    "id": 3,
    "title": "Getting Started with RFID Hacking: Tools and Techniques",
    "preview": "An introduction to RFID technology, vulnerabilities, and tools for security researchers and ethical hackers.",
    "content": "# Getting Started with RFID Hacking: Tools and Techniques\n\nRadio-Frequency Identification (RFID) technology is ubiquitous in modern life, from access cards and contactless payments to inventory tracking and pet microchips. This guide introduces security researchers and ethical hackers to RFID technologies, common vulnerabilities, and tools for testing and analyzing these systems.\n\n## Understanding RFID Technology\n\nRFID systems consist of two main components:\n\n1. **Tags/Cards**: Contain a microchip and antenna, which can be passive (powered by the reader's electromagnetic field) or active (battery-powered).\n2. **Readers**: Devices that emit radio waves to communicate with and read data from RFID tags.\n\nRFID systems operate on different frequencies:\n\n- **Low Frequency (LF)**: 125-134 kHz, used for animal tracking, access control\n- **High Frequency (HF)**: 13.56 MHz, used for payment cards, passports, NFC\n- **Ultra-High Frequency (UHF)**: 860-960 MHz, used for inventory tracking, toll collection\n\n## Common RFID Security Vulnerabilities\n\n- **Eavesdropping**: Intercepting communication between tag and reader\n- **Relay Attacks**: Forwarding signals between legitimate devices over longer distances\n- **Cloning**: Copying tag data to create unauthorized duplicates\n- **Unauthorized Reading**: Accessing tag information without owner's consent\n- **Weak Encryption**: Many older systems use broken or weak encryption schemes\n\n## Essential RFID Hacking Tools\n\n### Hardware Tools\n\n1. **Proxmark3**: The Swiss Army knife of RFID research, capable of working with multiple frequencies and protocols.\n   - Features: Sniffing, reading, cloning, emulation capabilities\n   - Price range: $100-$400 depending on version\n\n2. **RFID Killerbee**: Specifically designed for UHF RFID research.\n\n3. **ACR122U-A9**: Affordable NFC/RFID reader compatible with 13.56 MHz tags.\n   - Price range: $30-$50\n   - Compatible with: MIFARE, FeliCa, ISO 14443 A/B\n\n4. **ChameleonMini/Tiny**: Versatile RFID emulation device.\n   - Features: Can emulate multiple card types\n   - Price range: $60-$120\n\n### Software Tools\n\n1. **RFID Tools** (Android): Mobile app for reading various RFID/NFC tags.\n\n2. **Libnfc & Mfoc**: Open-source libraries and tools for NFC research.\n   - Features: Reading, writing, and cracking MIFARE Classic cards\n\n3. **RFIDiot**: Python library for exploring RFID devices.\n\n4. **Proxmark3 Client**: Software interface for the Proxmark3 device.\n\n## Basic RFID Hacking Techniques\n\n### 1. Reading Card Information\n\nUsing a Proxmark3 to read a MIFARE Classic card:\n\n```bash\n# Start the Proxmark3 client\n./proxmark3 /dev/ttyACM0\n\n# Detect the card type\nhf search\n\n# Read MIFARE Classic card information\nhf mf info\n```\n\n### 2. MIFARE Classic Cracking\n\nCracking a MIFARE Classic card with default keys:\n\n```bash\n# Using the Proxmark3\nhf mf chk *1 ? t\n\n# Or using mfoc\nmfoc -O output.dmp\n```\n\n### 3. Card Cloning\n\nCloning a MIFARE Classic card (after successfully reading it):\n\n```bash\n# Using the Proxmark3 to write the dumped data to a new card\nhf mf restore -f dumpfile.dmp\n```\n\n## Legal and Ethical Considerations\n\n- Only test RFID systems you own or have explicit permission to test\n- Unauthorized access to RFID systems may violate computer crime laws\n- Respect privacy - don't read others' RFID cards without consent\n- Responsibly disclose vulnerabilities you discover\n\n## Practical Exercise: Analyzing Access Cards\n\nTo apply these concepts, try this beginner exercise:\n\n1. Obtain a low-cost RFID development kit (reader + empty cards)\n2. Create a simple access control simulation\n3. Analyze the communication using an RFID reader\n4. Attempt to clone the card (for educational purposes only)\n5. Document security weaknesses and potential improvements\n\n*Ready to dive deeper into RFID security? Check out our [RFID Hacking Learning Path](/learning-paths) or get started with our [RFID Pentesting Kit](/hardware-library) which includes a Proxmark3 and various RFID sample cards.*",
    "category": "security",
    "imageUrl": "https://i.imgur.com/JDYCJhP.jpg",
    "authorId": 1,
    "publishedAt": "2025-04-12T11:45:00Z",
    "readTime": "10 min read",
    "tags": ["rfid", "security", "proxmark", "nfc", "ethical hacking", "hardware hacking"],
    "relatedArticleIds": [1, 2],
    "views": 317
  },
  {
    "id": 4,
    "title": "ESP32-CAM Security Camera: Building a WiFi Surveillance System",
    "preview": "Learn how to build a cost-effective WiFi security camera system using the ESP32-CAM module with motion detection and cloud storage capabilities.",
    "content": "# ESP32-CAM Security Camera: Building a WiFi Surveillance System\n\nThe ESP32-CAM is an incredibly versatile and cost-effective module that combines an ESP32 microcontroller with a camera. In this tutorial, we'll show you how to create a fully functional WiFi security camera with motion detection, web streaming, and optional cloud storage integration.\n\n## Components Required\n\n- ESP32-CAM module\n- FTDI programmer (for uploading code)\n- Breadboard and jumper wires\n- 5V power supply or USB adapter\n- Optional: PIR motion sensor\n- Optional: SD card for local storage\n\n## Step 1: Setting Up the Development Environment\n\n1. Install the Arduino IDE\n2. Add ESP32 board support in Arduino IDE\n3. Install required libraries:\n   - ESP32 Camera library\n   - WiFiManager (for easy WiFi configuration)\n   - ArduinoJson (for configuration handling)\n\n## Step 2: Wiring the ESP32-CAM for Programming\n\nTo program the ESP32-CAM, you need an FTDI programmer. Connect as follows:\n\n| ESP32-CAM | FTDI Programmer |\n|-----------|----------------|\n| 5V        | VCC (5V)       |\n| GND       | GND            |\n| U0R (RX)  | TX             |\n| U0T (TX)  | RX             |\n\nImportant: When uploading code, connect GPIO0 to GND to enter programming mode. Remove this connection after uploading.\n\n## Step 3: Basic Camera Code\n\nHere's a simplified version of the code that sets up the camera and creates a web server:\n\n```cpp\n#include \"esp_camera.h\"\n#include <WiFi.h>\n#include \"esp_timer.h\"\n#include \"img_converters.h\"\n#include \"soc/soc.h\"\n#include \"soc/rtc_cntl_reg.h\"\n\n// WiFi credentials\nconst char* ssid = \"YOUR_WIFI_SSID\";\nconst char* password = \"YOUR_WIFI_PASSWORD\";\n\n// Camera pins for AI-THINKER ESP32-CAM board\n#define PWDN_GPIO_NUM     32\n#define RESET_GPIO_NUM    -1\n#define XCLK_GPIO_NUM      0\n#define SIOD_GPIO_NUM     26\n#define SIOC_GPIO_NUM     27\n#define Y9_GPIO_NUM       35\n#define Y8_GPIO_NUM       34\n#define Y7_GPIO_NUM       39\n#define Y6_GPIO_NUM       36\n#define Y5_GPIO_NUM       21\n#define Y4_GPIO_NUM       19\n#define Y3_GPIO_NUM       18\n#define Y2_GPIO_NUM        5\n#define VSYNC_GPIO_NUM    25\n#define HREF_GPIO_NUM     23\n#define PCLK_GPIO_NUM     22\n\nWiFiServer server(80);\n\nvoid setup() {\n  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); // Disable brownout detector\n  \n  Serial.begin(115200);\n  Serial.setDebugOutput(true);\n  \n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer = LEDC_TIMER_0;\n  config.pin_d0 = Y2_GPIO_NUM;\n  config.pin_d1 = Y3_GPIO_NUM;\n  config.pin_d2 = Y4_GPIO_NUM;\n  config.pin_d3 = Y5_GPIO_NUM;\n  config.pin_d4 = Y6_GPIO_NUM;\n  config.pin_d5 = Y7_GPIO_NUM;\n  config.pin_d6 = Y8_GPIO_NUM;\n  config.pin_d7 = Y9_GPIO_NUM;\n  config.pin_xclk = XCLK_GPIO_NUM;\n  config.pin_pclk = PCLK_GPIO_NUM;\n  config.pin_vsync = VSYNC_GPIO_NUM;\n  config.pin_href = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn = PWDN_GPIO_NUM;\n  config.pin_reset = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n  config.pixel_format = PIXFORMAT_JPEG;\n  \n  // Initial settings for better quality\n  config.frame_size = FRAMESIZE_SVGA;\n  config.jpeg_quality = 10; // 0-63, lower is better quality\n  config.fb_count = 2;\n  \n  // Camera init\n  esp_err_t err = esp_camera_init(&config);\n  if (err != ESP_OK) {\n    Serial.printf(\"Camera init failed with error 0x%x\", err);\n    return;\n  }\n  \n  // Connect to WiFi\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected\");\n  Serial.println(\"IP address: \");\n  Serial.println(WiFi.localIP());\n  \n  // Start the web server\n  server.begin();\n}\n```\n\n## Final Thoughts\n\nYou now have a basic WiFi security camera. Possible next steps include adding motion detection, cloud storage integration, or custom enclosures. This project demonstrates how affordable hardware components can be used to create sophisticated security systems.\n\n*Want to build more advanced security systems? Check out our [ESP32 IoT Security Course](/learning-paths) or grab our [IoT Security Kit](/hardware-library) which includes pre-configured ESP32-CAM modules and sensors.*",
    "category": "hardware",
    "imageUrl": "https://i.imgur.com/dXnLFQq.jpg",
    "authorId": 3,
    "publishedAt": "2025-04-15T10:00:00Z",
    "readTime": "14 min read",
    "tags": ["esp32", "camera", "security", "iot", "wifi", "surveillance"],
    "relatedArticleIds": [1, 3],
    "views": 186
  }
]